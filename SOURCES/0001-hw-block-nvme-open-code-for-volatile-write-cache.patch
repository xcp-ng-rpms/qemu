From aa5e55e3b07ede87a8fd7aa3e67583dfc464dd52 Mon Sep 17 00:00:00 2001
From: Minwoo Im <minwoo.im.dev@gmail.com>
Date: Sun, 17 Jan 2021 23:53:32 +0900
Subject: [PATCH 1/1] hw/block/nvme: open code for volatile write cache

Volatile Write Cache(VWC) feature is set in nvme_ns_setup() in the
initial time.  This feature is related to block device backed,  but this
feature is controlled in controller level via Set/Get Features command.

This patch removed dependency between nvme and nvme-ns to manage the VWC
flag value.  Also, it open coded the Get Features for VWC to check all
namespaces attached to the controller, and if false detected, return
directly false.

Signed-off-by: Minwoo Im <minwoo.im.dev@gmail.com>
[k.jensen: report write cache preset if present on ANY namespace]
Signed-off-by: Klaus Jensen <k.jensen@samsung.com>
diff --git a/hw/block/nvme-ns.c b/hw/block/nvme-ns.c
index 64afc9d723c4..dd09a292078d 100644
--- a/hw/block/nvme-ns.c
+++ b/hw/block/nvme-ns.c
@@ -51,10 +51,6 @@ static int nvme_ns_init_blk(NvmeCtrl *n, NvmeNamespace *ns, Error **errp)
         return 1;
     }
 
-    if (blk_enable_write_cache(ns->conf.blk)) {
-        n->features.vwc = 0x1;
-    }
-
     return 0;
 }
 
diff --git a/hw/block/nvme.c b/hw/block/nvme.c
index de6261e70680..d696187f595a 100644
--- a/hw/block/nvme.c
+++ b/hw/block/nvme.c
@@ -1463,9 +1463,12 @@ static uint16_t nvme_get_feature_timestamp(NvmeCtrl *n, NvmeCmd *cmd,
 
 static uint16_t nvme_get_feature(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)
 {
+    NvmeNamespace *ns;
+
     uint32_t dw10 = le32_to_cpu(cmd->cdw10);
     uint32_t dw11 = le32_to_cpu(cmd->cdw11);
     uint32_t result;
+    int i;
 
     trace_nvme_getfeat(dw10);
 
@@ -1483,7 +1486,17 @@ static uint16_t nvme_get_feature(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)
         result = cpu_to_le32(n->features.err_rec);
         break;
     case NVME_VOLATILE_WRITE_CACHE:
-        result = cpu_to_le32(n->features.vwc);
+        for (i = 0; i < n->num_namespaces; i++) {
+            ns = n->namespaces[i];
+            if (!ns) {
+                continue;
+            }
+
+            result = cpu_to_le32(blk_enable_write_cache(ns->conf.blk));
+            if (result) {
+                break;
+            }
+        }
         trace_nvme_getfeat_vwcache(result ? "enabled" : "disabled");
         break;
     case NVME_NUMBER_OF_QUEUES:
@@ -1553,8 +1566,6 @@ static uint16_t nvme_set_feature(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)
         }
         break;
     case NVME_VOLATILE_WRITE_CACHE:
-        n->features.vwc = dw11 & 0x1;
-
         for (int i = 0; i < n->num_namespaces; i++) {
             ns = n->namespaces[i];
             if (!ns) {
diff --git a/include/block/nvme.h b/include/block/nvme.h
index 7d2c39d92b57..00ae8f780946 100644
--- a/include/block/nvme.h
+++ b/include/block/nvme.h
@@ -684,7 +684,6 @@ typedef struct NvmeFeatureVal {
     uint32_t    power_mgmt;
     uint32_t    temp_thresh;
     uint32_t    err_rec;
-    uint32_t    vwc;
     uint32_t    num_queues;
     uint32_t    int_coalescing;
     uint32_t    *int_vector_config;
